<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live Player Stats</title>
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #121212;
      color: #f1f1f1;
      margin: 0;
      padding: 20px;
    }
    h1 { text-align: center; margin-bottom: 20px; }
    .tabs { display: flex; justify-content: center; flex-wrap: wrap; }
    .tab-button {
      background: #1e1e1e; border: 1px solid #444; color: #fff;
      padding: 10px 20px; margin:5px; cursor:pointer; border-radius:5px;
      transition: background 0.3s;
    }
    .tab-button.active { background: #4caf50; }
    .chart-container { display:none; max-width:1000px; margin:40px auto; }
    .chart-container.active { display:block; }
    canvas { max-height:500px; width:100%; }
    #endMessage { display:none; text-align:center; margin:20px; font-size:1.2em; color:#bbb; }
    #controlButtons { text-align:center; margin-bottom:15px; }
    #controlButtons button {
      background:#1e1e1e; color:#f1f1f1; border:1px solid #555;
      padding:8px 14px; margin:0 5px; border-radius:4px; cursor:pointer;
    }
    #controlButtons button:hover { background:#4caf50; }
    .legend-container { display:flex; justify-content:center; margin-bottom:20px; }
    .legend-column {
      display:flex; flex-direction:column; margin:0 20px; gap:6px;
    }
    .legend-item {
      display:flex; align-items:center;
      background: #1e1e1e;
      border: 1px solid #555;
      padding: 6px 10px;
      border-radius: 6px;
      cursor:pointer;
      color:#f1f1f1;
      user-select:none;
      transition: opacity 0.2s ease;
    }
    .legend-item.hidden { opacity:0.4; }
    .legend-item img { width:24px; height:24px; margin-right:8px; }
    .legend-item span { font-size:14px; }
  </style>
</head>
<body>
  <h1>Live Player Stats</h1>
  <div id="endMessage">?? Stream ended.</div>
  <div id="controlButtons">
    <button id="selectAllBtn">Select All</button>
    <button id="unselectAllBtn">Unselect All</button>
  </div>
  <div class="legend-container" id="customLegend"></div>
  <div class="tabs" id="tabs"></div>
  <div id="charts-container"></div>

  <script>
    const socket = io();
    const stats = ['assists','deaths','kills','hero_damage','hero_healing','last_hits','net_worth','objective_damage'];
    const dataStore = {}, charts = {}, containers = {};
    const allPlayers = {};
    const hiddenState = {};
    let heroMap = {};
    const teamColors = {2:'rgba(54,162,235,0.8)',3:'rgba(255,99,132,0.8)'};
    const maxPoints = 1000;
    const buffer = {};

    const playerKey = d => `${d.steam_name} (${d.hero_name})`;
    const formatGameTime = sec => `${Math.floor(sec/60)}:${(sec%60).toString().padStart(2,'0')}`;

    async function fetchHeroList(){
      try {
        const res = await fetch('https://assets.deadlock-api.com/v2/heroes');
        const heroes = await res.json();
        heroes.forEach(h => heroMap[h.id] = {name: h.name, img: h.images.minimap_image});
      } catch (err) {
        console.error('Failed to fetch heroes', err);
      }
    }

    async function fetchCachedData(){
      try {
        const res = await fetch('/cached-data');
        if (!res.ok) throw new Error('Failed to load cached data');
        const cached = await res.json();
        const combined = {};

        for (const stat of stats) {
          const statBlock = cached[stat];
          if (!statBlock) continue;

          for (const key in statBlock) {
            const matches = key.match(/^(.*) \((.*)\) \[Team (\d+)\]$/);
            if (!matches) continue;

            const [, steam_name, hero_name, teamStr] = matches;
            const team = parseInt(teamStr);
            const hero_id = Object.entries(heroMap).find(([, val]) => val.name === hero_name)?.[0];

            statBlock[key].forEach(point => {
              const gt = point.x;
              const objKey = `${steam_name}|${gt}`;

              if (!combined[objKey]) {
                combined[objKey] = {
                  steam_name,
                  hero_name,
                  hero_id: Number(hero_id),
                  team,
                  game_time: gt
                };
              }

              combined[objKey][stat] = point.y;
            });
          }
        }

        const batch = Object.values(combined);
        updateCharts(batch);

      } catch (e) {
        console.error('Error fetching cached data:', e);
      }
    }

    function createUI(){
      const tabs = document.getElementById('tabs'), area = document.getElementById('charts-container');
      stats.forEach((stat,i)=>{
        const btn = document.createElement('button');
        btn.className='tab-button'+(i===0?' active':'');
        btn.innerText = stat.replace('_',' ').toUpperCase();
        btn.dataset.stat=stat;
        tabs.appendChild(btn);

        const wrapper = document.createElement('div');
        wrapper.className='chart-container'+(i===0?' active':'');
        const canvas = document.createElement('canvas');
        canvas.id = `chart-${stat}`;
        wrapper.appendChild(canvas);
        area.appendChild(wrapper);
        containers[stat] = wrapper;

        btn.onclick = ()=> {
          document.querySelectorAll('.tab-button').forEach(b=>b.classList.remove('active'));
          document.querySelectorAll('.chart-container').forEach(c=>c.classList.remove('active'));
          btn.classList.add('active');
          wrapper.classList.add('active');
        };

        dataStore[stat] = {};
        charts[stat] = new Chart(canvas.getContext('2d'), {
          type:'line',
          data:{datasets:[]},
          options:{
            animation:false, responsive:true,
            plugins:{
              title:{display:true,text:stat.replace('_',' ').toUpperCase(),color:'#fff',font:{size:18}},
              legend:{ display:false },
              tooltip:{
                mode:'nearest', intersect:false,
                callbacks:{
                  title: items => items.length>0 ? `Time: ${formatGameTime(items[0].parsed.x)}` : '',
                  label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y}`
                }
              }
            },
            scales:{
              x:{
                type:'linear',
                title:{display:true,text:'Game Time (min:sec)',color:'#fff'},
                ticks:{ color:'#fff', callback: v=> formatGameTime(v) },
                grid:{color:'#444'}
              },
              y:{
                beginAtZero:true,
                title:{display:true,text:stat.replace('_',' '),color:'#fff'},
                ticks:{color:'#fff'}, grid:{color:'#444'}
              }
            }
          }
        });
      });
    }

    function syncLegend() {
      const legendDiv = document.getElementById('customLegend');
      legendDiv.innerHTML = '';

      const col2 = document.createElement('div'), col3 = document.createElement('div');
      col2.className = col3.className = 'legend-column';

      Object.entries(allPlayers).forEach(([key, meta]) => {
        const item = document.createElement('div');
        item.className = 'legend-item';

        if (hiddenState[key]) {
          item.classList.add('hidden');
        }

        const hero = heroMap[meta.hero_id];
        if (hero && hero.img) {
          const img = document.createElement('img');
          img.src = hero.img;
          item.appendChild(img);
        }

        const span = document.createElement('span');
        span.innerText = `${meta.steam_name} (${meta.hero_name})`;
        item.appendChild(span);

        item.onclick = () => {
          const nowHidden = !hiddenState[key];
          hiddenState[key] = nowHidden;

          stats.forEach(stat => {
            const chart = charts[stat];
            chart.data.datasets.forEach(ds => {
              if (ds.label === key) {
                ds.hidden = nowHidden;
              }
            });
            chart.update('none');
          });

          item.classList.toggle('hidden', nowHidden);
        };

        (meta.team === 2 ? col2 : col3).appendChild(item);
      });

      legendDiv.appendChild(col2);
      legendDiv.appendChild(col3);
    }

    function updateCharts(batch){
      stats.forEach(stat=>{
        batch.forEach(ps=>{
          if(ps[stat] === undefined || (ps.team !== 2 && ps.team !== 3)) return;
          const key = playerKey(ps);

          if (!allPlayers[key]) {
            allPlayers[key] = {
              steam_name: ps.steam_name,
              hero_name: ps.hero_name,
              hero_id: ps.hero_id,
              team: ps.team
            };
          }

          if (!(key in hiddenState)) {
            hiddenState[key] = false;
          }

          if(!dataStore[stat][key]){
            dataStore[stat][key] = [];
            charts[stat].data.datasets.push({
              label: key,
              data: dataStore[stat][key],
              borderColor: teamColors[ps.team] || '#888',
              backgroundColor: 'transparent',
              fill: false,
              tension: 0.2,
              pointRadius: 2,
              borderWidth: 2,
              hidden: hiddenState[key]
            });
          }

          const arr = dataStore[stat][key];
          if (!arr.some(p => p.x === ps.game_time)) {
            arr.push({x: ps.game_time, y: ps[stat]});
            if(arr.length > maxPoints) arr.shift();
          }
        });
        charts[stat].update('none');
      });

      syncLegend();
    }

    document.getElementById('selectAllBtn').onclick = () => {
      Object.keys(hiddenState).forEach(k => hiddenState[k] = false);
      Object.values(charts).forEach(chart => {
        chart.data.datasets.forEach(ds => ds.hidden = false);
        chart.update('none');
      });
      syncLegend();
    };

    document.getElementById('unselectAllBtn').onclick = () => {
      Object.keys(hiddenState).forEach(k => hiddenState[k] = true);
      Object.values(charts).forEach(chart => {
        chart.data.datasets.forEach(ds => ds.hidden = true);
        chart.update('none');
      });
      syncLegend();
    };

    async function init(){
      await fetchHeroList();
      createUI();
      await fetchCachedData();
      socket.on('player_update', d=>{
        if(d.team === 2 || d.team === 3){
          buffer[playerKey(d)] = d;
        }
      });
      socket.on('stream_end', ()=>{
        document.getElementById('endMessage').style.display = 'block';
      });
      setInterval(()=>{
        const batch = Object.values(buffer);
        if(batch.length){
          updateCharts(batch);
          Object.keys(buffer).forEach(k=>delete buffer[k]);
        }
      },1000);
    }

    init();
  </script>
</body>
</html>